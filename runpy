#!/usr/bin/python3

import argparse
import logging
import os.path
import shutil
import subprocess
import time

# init logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# parse arguments
parser = argparse.ArgumentParser()
parser.add_argument("INTERPRETER",
        help="the interpreter the file should be executed with",
        type=str)
parser.add_argument("FILE",
        help="file to be executed", type=str)
args = parser.parse_args()

# get args from argparse
interpreter = args.INTERPRETER
file = args.FILE

# check if interpreter is valid
if not shutil.which(interpreter):
    logger.error(interpreter, "not found")
    exit()

# check if file is valid
if not os.path.isfile(file):
    logger.error(file, "not found")
    exit()

# This while runs until you press ctr-c
# This must be changed to a more elegant soution!!!
while True:
    # read file
    text = open(file).read()

    # check if file content has changed
    # and sleep for 1 sec
    while text == open(file).read():
        time.sleep(1)

    # get screen width
    dims = subprocess.check_output(['stty size', 'r'],
            shell=True).split()
    width = int(dims[1].decode('utf-8'))

    # make title string
    hash_row = "#" * int((width / 2 - 12))
    title = hash_row, "Executing New Version", hash_row

    # print title
    print(title)

    # get time before command execution
    start_time = time.time()

    # execute command
    subprocess.call([interpreter, file])

    # make result-title string
    hash_row = "#" * int((width / 2 - 9))
    result_title = hash_row, "Performance Data", hash_row

    # print result-title
    print(result_title)

    # print time the command has taken
    exec_time = str(time.time() - start_time) + " sec"
    whitespaces = " " * (width - len(exec_time) - 5
    print("#", exec_time, whitespaces, "#")

    # print end seperator and newline
    print("#" * width + "\n")
